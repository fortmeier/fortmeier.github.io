---
layout: post
title:  "Autoneedle"
date:   2014-01-02 21:07:47
categories: science
tech: C++, VTK, CMake, Python, SymPy, GTest
teaserimage: "/images/autoneedle_teaser.png"
---

I experimented with the SymPy library with the purpose to generate C++ code directly from differential equations and energy terms.

In the course of my PhD project, I came along the problem of computation of deformations for bendable needles. I knew that formulations of the energies of deformable rods were given in [1][2] and wanted to generate C++ code without having to derive the necessary formulation by hand. Instead, I wrote Python code that did the tedious work for me.

In the end, the code could be used to generate code for the needed Jacobians but which was not fast enough to be usable in visuo-haptic simulation.
For instance, a single component of 

For this, the discrete bending energy term of [1], p. 4 was translated into sympy code for a discrete element consisting of three vertiecs of the elastic rod. The resulting energy term is then differentiated to obtain forces and elements of the Jacobian:


{% highlight python lineos %}

import sympy

...
# define 3 adjacent vertices
a = symbols('a[0] a[1] a[2]')
b = symbols('b[0] b[1] b[2]')
c = symbols('c[0] c[1] c[2]')


Ebend = dot(kbi,kbi)*k1/ld
Estretch = l1 + l2

E = Ebend + Estretch

% differentiate the energy term with respect
% to the first component of the middle vertex
% to obtain the force acting on the it in
% x direction
Fx = -diff(E, b[0])

{% endhighlight %}

Sympy contains methods to convert the resulting symbolic representation to C code, the results then looks something like this:

{% highlight c++ lineos %}
// autogenerated function
Real needle_Fx( const Vector& a, const Vector& b, const Vector& c, const Real& k1, const Real& l0 )
{
  Real tmp0 = -a[0] + b[0];
  Real tmp1 = -b[0];
  Real tmp2 = -b[1];
  Real tmp3 = -b[2];
  Real tmp4 = sqrt(pow(a[0] + tmp1, 2) + pow(a[1] + tmp2, 2) + pow(a[2] + tmp3, 2));
  Real tmp5 = -l0;
  Real tmp6 = b[0] - c[0];
  Real tmp7 = sqrt(pow(tmp6, 2) + pow(b[1] - c[1], 2) + pow(b[2] - c[2], 2));
  Real tmp8 = pow(l0, 2);
  Real tmp9 = c[1] + tmp2;
  Real tmp10 = -2*a[0];
  Real tmp11 = 2*b[0] + tmp10;
  Real tmp12 = c[0] + tmp1;
  Real tmp13 = -2*a[1] + 2*b[1];
  Real tmp14 = tmp11*tmp9 - tmp12*tmp13;
  Real tmp15 = c[2] + tmp3;
  Real tmp16 = tmp0*tmp12 + tmp15*(-a[2] + b[2]) + tmp8 + tmp9*(-a[1] + b[1]);
  Real tmp17 = pow(tmp16, -2);
  Real tmp18 = -2*a[2] + 2*b[2];
  Real tmp19 = -tmp11*tmp15 + tmp12*tmp18;
  Real tmp20 = (4*b[0] - 2*c[0] + tmp10)/pow(tmp16, 3);
  Real r = -1.0L/2.0L*k1*(pow(tmp14, 2)*tmp20 + tmp14*tmp17*(-4*a[1] + 4*c[1]) + tmp17*tmp19*(4*a[2] - 4*c[2]) + pow(tmp19, 2)*tmp20 + tmp20*pow(tmp13*tmp15 - tmp18*tmp9, 2))/sqrt(tmp8) - 2000.2*tmp0*(tmp4 + tmp5)/tmp4 - 2000.2*tmp6*(tmp5 + tmp7)/tmp7;
  return r;
}

{% endhighlight %}

* [1] Bergou, M., Wardetzky, M., Robinson, S., Audoly, B., & Grinspun, E. (2008). Discrete Elastic Rods. ACM Transactions on Graphics, 27(3)

* [2] Spillmann, J., & Teschner, M. (2007). CORDE: Cosserat Rod Elements for the Dynamic Simulation of One-Dimensional Elastic Objects. ACM SIGGRAPH 2007 Symposium on Computer Animation, 1.
